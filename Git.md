# 1 Git

git是一个强大的分布式版本管理系统

## 1.1  版本 

版本可以记录一个或若干个文件的内容的变化，比如书的版本的修订，以及软件的版本发布更新等。新的版本在旧的版本上基础上不断地修改、增加、删除。更新版本的内容。最后就衍生出了不同的版本。不好管理。比如你写论文的时候，刚开始写了一部分然后你保存之后，过了一段时间继续去写，写了一部分想删除其中的某一部分，但是又害怕将来想恢复找不回来，于是你保存当前的文件又新建了一个文件，再接着改，这样一直改下去你的word文档出现了好多副本，过一段时间你想找回被删除的段落，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删。这时版本控制系统就可以解决这些问题。它可以记录每次文件的改动，即在什么时间修改了什么内容？

## 1.2 版本控制系统

为什么会有版本控制系统呢？版本控制系统可以很方便的管理你的软件，它可以记录你文件具体的修改时间，以及修改了哪些内容，当你想要查看某个版本的时候，你可以很方便的查找到。而如果没有版本控制系统的话，你就会很困难的去管理你修改的那些文件，除非你给每个文件上都标注在什么时间，修改了什么内容，这样无形中就浪费了大量时间，而版本控制系统就为你做了这些事，它可以记录你每个文件在什么时间修改以及修改了哪些内容，记录你每次文件的改动，不用你手动的去管理。

### 1.2.1 集中式版本控制系统

集中式版本控制系统典型代表是SVN，它只有一个服务器，每个人从服务器上获取项目当前最新版本，然后干活，完成任务后再把自己的修改提交到服务器上，但是单个服务器引发的问题就是冲突问题、还有如果服务器挂了，其他人都没法工作了。如果硬盘坏了，服务器在没有备份的情况下将会丢失数据。如果断网的话，就无法提交代码。但是集中式版本控制系统易于管理，管理员可以设置权限，谁可以访问，谁不可以访问。SVN要求每次提交的代码必须是测试过的，没有任何bug的，但是问题来了，如果我的代码还有一些bug需要修改暂时不能提交，那么我现在的代码将保存在哪？万一丢失了找不回怎么办？那么我之前的工作不是白做了。这就是集中式版本控制系统缺点。而分布式版本控制系统解决了这个问题。

### 1.2.2 分布式版本控制系统

git就是一个分布式版本控制系统。每个人的电脑上都有一个完整的库，只要交换对方的修改就行，把各自的修改推送给对方。git的分支管理功能强大，可以很方便的查询和追溯分支间的提交历史，每个人的电脑都是一个关键节点，每个点都拥有所有的资料和变动记录，有详细的变更记录，解决了我做了什么，你做了什么，你在什么地方做了怎样的变动，减少了大量的沟通成本，并且能够保证所有人的资料都是最新的，分支切换快速高效，创建和销毁分支廉价安全性高，因为每个人的电脑里都有完整的库，某个人的电脑坏掉了不要紧，随便从其他人那里复制一下就好了，还有就是分布式版本控制系统在没有网的情况下也可以提交代码。

## 1.3 工作区

工作区可以理解为在你的电脑上所能看到的目录。

## 1.4 版本库

版本库可以理解为仓库，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。工作区里面有个.git隐藏目录，这个目录就是git的版本库，在这个目录下有个index文件，称作暂存区，还有git创建的第一个分支master和指向master的指针HEAD

## 1.5 暂存区

git add把文件从工作区添加到暂存区，然后通过git commit将暂存区的文件提交到当前分支，暂存区可以理解为网购中的购物车，看到了感兴趣的物品，我们可以把商品添加到购物车(暂存区)，我们可能会频繁的，添加商品或者移除商品，在这个过程中我们可以随便嗨，反正还没给钱；接着我们挑的差不多了，我们就要提交订单了，点击提交订单(commit)，接着会生成一个商品的订单列表，此时订单提交了，但是我们还没支付(Push)，我们可以在自己的账户未支付订单列表(本地仓库)中找到我们的这个订单，也可以看到自己以前的一些订单记录；再接着我们选择这个还没付款的订单，进行支付(Push)，付款完成后，商家(远程仓库)就会收到这个订单，然后发货…

有了暂存区我们可以很方便的修改、增加、删除，直到我们修改满意了再提交。

## 1.6 远程仓库

github上有很多远程仓库，一个文件夹就算一个仓库，自己的github账号中每个repository就是一个远程仓库

目的：将本地文件推送到自己建的远程仓库中

作用：将本地仓库和远程仓库关联起来，传送文件，可以push，可以clone，可以pull

## 1.7 分支

### 1.7.1 分支是什么？

分支就是可以从主线上分离开来，然后在不影响主线的同时继续工作。分支是一条线，只有一条线的分支是主分支，即master分支，git用master指向最新的提交，用HEAD指向master,HEAD指向的是当前分支

  ![git-br-initial](https://www.liaoxuefeng.com/files/attachments/0013849087937492135fbf4bbd24dfcbc18349a8a59d36d000/0)

### 1.7.2 分支的作用

（1）在软件开发中，如果想要在你的项目中添加一些功能，你不可能直接在主分支上直接修改代码，因为万一你修改的有问题，那么就会给主分支带来很大的麻烦，这时你需要建立一些分支，在这些分支上完成你要的功能，最后把这些分支合并到主分支上。

（2）分支可以保留开发中可能出现的各种bug方便修复但不影响主分支的使用

（3）保证主线代码的完整性和可用性，主线是稳定的，可以直接发布的

### 1.7.3 创建合并分支

当我们创建一个新的分支的时候，例如dev,git就会新建一个指针dev,指向和master相同的提交，再把HEAD指向dev,就表示当前分支在dev上

  ![git-br-create](https://www.liaoxuefeng.com/files/attachments/001384908811773187a597e2d844eefb11f5cf5d56135ca000/0)



现在对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针就向前移动一步，指向最新提交，而master指针指向不变                                                                           ![git-br-dev-fd](https://www.liaoxuefeng.com/files/attachments/0013849088235627813efe7649b4f008900e5365bb72323000/0)

把dev合并到master上，直接把master指向dev的当前提交，就完成了合并                                                                                   

  ![git-br-ff-merge](https://www.liaoxuefeng.com/files/attachments/00138490883510324231a837e5d4aee844d3e4692ba50f5000/0)

删除分支dev，就剩下一个master分支                                                                                      

  ![git-br-rm](https://www.liaoxuefeng.com/files/attachments/001384908867187c83ca970bf0f46efa19badad99c40235000/0)

### 1.7.4 merge和rebase

开发进程分叉到两个不同分支，两个分支各自前进了，又各自提交了更新。如下图                                           

![img](http://my.csdn.net/uploads/201206/14/1339682809_4752.jpg)

如果用merge整合的话，它会把两个分支最新的提交（C6 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是产生一个新的提交对象（C7）。如下图所示：                                               

![img](http://my.csdn.net/uploads/201206/14/1339682845_9921.jpg)

 如果用 rebase整合的话，会把"mywork"分支里的每个提交(commit)取消掉，并且把它们临时保存为补丁(patch)然后把"mywork"分支更新为最新的"origin"分支，最后把保存的这些补丁应用到"mywork"分支上。                        

![img](http://my.csdn.net/uploads/201206/14/1339682915_7495.jpg)

当'mywork'分支更新之后，它会指向这些新创建的提交(commit),而那些旧的提交会被丢弃。

![img](http://my.csdn.net/uploads/201206/14/1339682976_4523.jpg)

现在我们可以看一下用合并(merge)和用rebase所产生的区别：

![img](http://my.csdn.net/uploads/201206/14/1339683149_4793.jpg)

当我们使用Git log来参看commit时，其commit的顺序也有所不同。

假设C3提交于9:00AM,C5提交于10:00AM,C4提交于11:00AM，C6提交于12:00AM,

对于使用git merge来合并所看到的commit的顺序（从新到旧）是：C7 ,C6,C4,C5,C3,C2,C1

对于使用git rebase来合并所看到的commit的顺序（从新到旧）是：C6‘,C5',C4,C3,C2,C1

 因为C6'提交只是C6提交的克隆，C5'提交只是C5提交的克隆，

# 1.8 标签

### 1.8.1 标签是什么？

标签就是一个让人容易记住的有意义的名字，它跟某个commit绑定

### 1.8.2 为什么要引入标签？

git虽然有commit，但是这个commit_id很长，一串乱七八糟的数字不好找，这时引入标签，比如版本号是v1.0 这时候按照tag v1.0查找commit就行

### 1.8.3 git中创建标签

首先切换到需要打标签的分支上，然后敲命令git tag <name> 就可以打一个新标签

默认的标签是打在最新提交的commit上的，如果忘了打标签，需要找到历史提交的commit id.

### 1.8.4 在git中操作标签

（1）如果标签打错了可以删除，因为创建的标签只存储在本地，不会自动推送到远程，所以打错的标签可以在本地安全删除

（2）推送某个标签到远程， git push origin <tagname>

（3）一次性推送全部尚未推送到远程的本地标签  ：git  push origin --tags

（4）如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：然后，从远程删除。删除命令也是push，但是格式如下：git push origin :refs/tags/v0.9

## 1.9 git上传代码到github遇到的问题

(1)输入$ git remote add origin git@github.com:（github帐号名）/（项目名）.git
提示出错信息：fatal: remote origin already exists.

解决办法如下：
先输入$ git remote rm origin
再输入$ git remote add origin git@github.com:（github帐号名）/（项目名）.git 就不会报错了！

(2)输入$ git push -u origin master

提示出错信息：failed to push some refs to git

出现错误的主要原因是github中的README.md文件不在本地代码目录中

可以通过如下命令进行代码合并[注：pull=fetch+merge]

git pull --rebase origin master执行上面代码后可以看到本地代码库中多了README.md文件

此时再执行语句 git push -u origin master即可完成代码上传到github

## 1.10 常用命令

### 1.10.1 创建版本库

创建git仓库文件夹，名为：`learngit`

```
 $ mkdir learngit
```

进入leadngit文件夹

```
 $ cd learngit

```

初始化git仓库

```
 $ git init 

```

### 1.10.2 添加文件

在`leangit`下添加一个`readme.txt`文件，并编辑一些内容

添加到仓库暂存区

```
 $ git add readme.txt	

```

提交readme.txt文件到当前分支, -m "提交说明"(只有进行 git add 后 go commit 命令才有效)

```
 $ git commit -m "add readme.txt"		
```

查看仓库状态

```
 $ git status

```

### 1.10.3  撤销修改文件（未提交到分支）

#### 当文件在工作区时

执行撤销命令

```
 $ git checkout -- readme.txt

```

#### 当文件在暂存区时

令文件回到工作区

```
 $ git reset HEAD readme.txt

```

执行撤销命令

```
 $ git checkout -- readme.txt

```

#### 版本控制

在Git中，`HEAD`表示当前版本，`HEAD^`表示上一版本 `HEAD^^`表示上上一个版本

查看提交日志输出(完整版)

```
 $ git log 

```

查看提交日志输出（精简版）

```
 $ git log --pretty=noline

```

回到上一版本

```
 $ git reset --hard HEAD^

```

回到指定版本（hard 后面添加版本号）

```
 $ git reset --hard ea34578

```

查看命令历史

```
 $ git reflog

```

### 1.10.4 远程仓库（github）

#### 添加到远程库

在github上创建一个名为`learngit`的空仓库

在本地`learngit`仓库下运行命令

```
 $ git remote add origin git@github.com:（github帐号名）/learngit.git
```

把本地内容推送到github远程库上(第一次push 参数带 `-u` 关联远程仓库)

```
 $ git push -u origin master
```

#### 从远程仓库更新本地仓库（已关联）

```
	$ git pull origin master

```

### 1.10.5 分支管理

- 查看分支

  ```
    $ git branch

  ```

- 创建`newBranch`分支

  ```
    $ git branch newBranch

  ```

- 切换`HEAD`指向`newBranch`分支

  ```
    $ git checkout newBranch

  ```

- 创建+切换分支

  ```
    $ git checkout -b newBranck

  ```

- 合并某分支到当前分支

  ```
    $ git merge newBranch

  ```

- 普通删除`newBranch`分支

  ```
    $ git branch -d newBranch

  ```

- 强行删除`newBranch`分支

  ```
    $ git branch -D newBranch

  ```

- 查看分支合并状况

  ```
    $ git log --graph --pretty=oneline --abbrev-commit
  ```

### 1.10.6 多人协作

- 查看远程库信息

  ```
    $ git remote

  ```

- 详细查看远程信息

  ```
   $ git remote -v

  ```

- 推送分支到远程库

  ```
   $ git remote origin master

  ```

- 抓取远程分支

  ```
   $ git pull origin master

  ```

### 1.10.7 标签管理

- 创建一个标签，默认为`HEAD`当前分支添加标签

  ```
   $ git tag v1.0

  ```

- 为版本号为`e8b8ef6`添加`v2.0`标签

  ```
   $ git tag v2.0 e8b8ef6

  ```

- 为版本号为`6cb5a9e`添加带有说明的标签，`-a`指定标签名,`-m`指定说明文字

  ```
   $ git tag -a v3.0 -m "version 0.2 released" 6cb5a9e

  ```

- 根据标签查看指定分支

  ```
   $ git show v0.2

  ```

- 查看所有标签

  ```
   $ git tag

  ```

- 删除`v1.0`标签

  ```
   $ git tag -d v1.0

  ```

- 把`v0.9`标签推送到远程

  ```
   $ git push origin v0.9

  ```

- 推送所有尚未推送到远程的本地标签

  ```
   $ git push origin --tags

  ```

- 删除远程标签, 先删除本地标签，再删除远程标签

  ```
   $ git tag -d v0.9
   $ git push origin :refs/tags/v0.9 
  ```