# 1 进程和线程

## 1.1 什么是进程和线程？

计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。一个车间里，可以有很多工人。他们协同完成一个任务。线程就好比车间里的工人。一个进程可以包括多个线程。车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫"互斥锁"（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做"信号量"（Semaphore），用来保证多个线程不会互相冲突。

## 1.2 进程和线程的对比

在Windows中，开辟一个进程的开销通常在几秒中左右，这个开销已经非常昂贵。开辟进程时，必须给进程分配相应的内存，还得初始化内存；同时，进程需要执行程序的exe和相关的DLL文件需要从磁盘上加载等。与进程相比，在Windows中创建一个线程的开销则少很多。因为各线程间可以共享资源和程序。但是，由此而来也会带来额外的开销：

（1）线程越多，占用的内存越多；

（2）线程也需要CPU花费时间周期去管理和调度；

（3）大量线程存在，严重考验调度算法的健壮性和复杂性，也影响线程的平均等待时间。

因此，需要记住：线程并不廉价，需要根据实际需要开辟线程。

## 1.3 多线程

**1.3.1 什么时候应该用多线程：**

·  一个普通的多线程程序在后台运行耗时的任务时。主线程保持运行状态，工作线程干后台的活。在Windows Form程序里，如果主线程被长时间占用，键盘和鼠标的操作就不能处理了，然后程序就变成“无响应”了。所以，需要把耗时的任务放在后台运行，让主线程保证响应用户输入。

· 在非UI程序中，比如Windows服务，多线程就特别有用了，当等待另一台机器（例如一个应用服务器，数据库服务器，客户端）的响应时，用一个工作线程来等待，让主线程保持畅通。

· 多线程的另一个用处是在函数中有大量计算时，函数划成多个线程可以在多核的机器上执行更快（可以用Environment.ProcessorCount得到CPU核心数量）。

· 一个C#程序可以通过两种方式成为多线程：显示地创建线程，或者使用.NET显示创建线程的功能（比如BackgroundWorker，线程池，定时器，远程服务器，WebSerivce或ASP.NET程序），在后面这些情况下，只能是多线程。单线程的web服务器肯定不行。在无状态的web服务器里，多线程是相当简单的。主要的问题是如果处理缓存数据的锁机制。

**1.3.2 什么时候不应该用多线程：**

· 多线程也有缺点，最大的问题是会让程序变得复杂，多线程本身并不复杂，复杂在于线程间的交互。能让开发周期变长，以及Bug变多。所以需要把多个线程间的交互设计的尽量简单，或者就别用多线程，除非你可以保证的很好。

· 过多地在线程间切换和分配内存栈，也会带来CPU资源的消耗，通常，当硬盘IO很多时，只有一两个线程依次执行任务的程序性能要更好，而多个性能同时执行一个任务的性能不怎么样。

## 1.4 多线程之间如何同步

**1.4.1 lock锁，为什么要lock,lock了什么？**

当我们使用线程的时候，效率最高的方式当然是异步，即各个线程同时运行，其间不相互依赖和等待。但当不同的线程都需要访问某个资源的时候，就需要同步机制了，也就是说当对同一个资源进行读写的时候，我们要使该资源在同一时刻只能被一个线程操作，以确保每个操作都是有效即时的，也即保证其操作的原子性。lock是C#中最常用的同步方式，格式为lock(objectA){codeB} 
lock(objectA){codeB} 看似简单，实际上有三个意思，这对于适当地使用它至关重要：
（1） objectA被lock了吗？没有则由我来lock，否则一直等待，直至objectA被释放。
（2） lock以后在执行codeB的期间其他线程不能调用codeB，也不能使用objectA。
（3） 执行完codeB之后释放objectA，并且codeB可以被其他线程访问。

**1.4.2 互斥锁（Mutex）**

互斥锁是一个互斥的同步对象，意味着同一时间有且仅有一个线程可以获取它。互斥锁可适用于一个共享资源每次只能被一个线程访问的情况。我们可以把Mutex看作一个出租车，乘客看作线程。乘客首先等车，然后上车，最后下车。当一个乘客在车上时，其他乘客就只有等他下车以后才可以上车。而 线程与C# Mutex对象的关系也正是如此，线程使用Mutex.WaitOne()方法等待C# Mutex对象被释放，如果它等待的C# Mutex对象被释放了，它就自动拥有这个对象，直到它调用Mutex.ReleaseMutex()方法释放这个对象，而在此期间，其他想要获取这个 C# Mutex对象的线程都只有等待。如果要获取一个互斥锁。应调用互斥锁上的WaitOne()方法，该方法继承于Thread.WaitHandle类，它处于等待状态直至所调用互斥锁被获取，因此该方法将组织主调线程直到指定的互斥锁可用，如果不需要拥有互斥锁，用ReleaseMutex方法释放，从而使互斥锁可以被另外一个线程所获取.

**1.4.3 semaphore**

其中lock 和mutex 差不多，都是锁定同一个资源，不同之处是mutex在整个进程中都可以访问到。而semaphore是锁定多个资源，比如同一时期只能有两个线程访问，其它线程只能等待其中之一释放锁才能使用，Semaphore就是一个可以多次进入的“Mutex”。Mutex永远只允许一个线程拥有它，而Semaphore可以允许多个线程请求，因此Semaphore被用于管理一次可以允许多个线程进入并发访问资源的情况。

# 1.5 线程安全

多线程编程相对于单线程会出现一个特有的问题，就是线程安全的问题。所谓的线程安全，就是如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的就是线程安全的。 线程安全问题都是由全局变量及静态变量引起的。

线程安全一般都是在非主线程调用了控件，因此一般当在辅助线程调用控件（或赋值之类的）时再委托主线程的方法去引用控件。

**1.5.1 如何才能保证线程安全？**

​      为什么应用多线程就不安全了呢？

​      线程安全的一个判定指标，线程之间有没有临界资源，如果有临界资源，且没有采用合理的同步机制，就会出现多个线程竞争一个资源，如若多个线程都在为得不到所需的资源，则会发生死锁。死锁，线程就会彼此僵持，系统停滞不前，如果后果严重，则直接导致系统崩溃。常见的案例有：生产者与消费者问题、哲学家就餐问题等。

​     生产者消费者问题：一个同步程序，生产者向一个缓冲区中写入数据，消费者从中提取数 据，如果缓冲区中没有数据，那么consumer只好wait，进入等待状态，当另一个线程(也就是生产者)向缓冲区中写入数据后，执行了Monitor.pulse,唤醒了consumer的等待，开始读取数据。反之，当producer写入数据的时候, 如果缓冲区已满， 那么只好进入等待状态，当另一个线程(也就是消费者) 从中读取了数据， 缓冲区有了空间，那么消费者执行 Monitor.pulse，唤醒生产者，继续写入数据。程序使用了lock来锁定共享数据区，而不是使用Monitor.enter和Monitor.exit，因为你可能很容易忘记enter后exit掉，而lock则是隐式的执行了exit，所以建议用lock。当然, 在程序执行的过程中，因为是线程，所以执行结果是不可再现的!!每次可能执行的顺序有很多种!!

      根据哲学家就餐问题做个简化：两个人去餐馆吃饭，由于资源紧张，只有一双筷子，两个人都饿了，都想吃饭，且同时去抢筷子，势均力敌，两人每人抢到一根筷子，只有使用一双筷子才能吃饭。这时你会说了，我可以用手抓着吃，呵呵。如果是刚出锅的饺子，怕你抓不起来。两个人只能面面相觑，大眼瞪小眼，就是吃不上。如果僵持个一年半载，都饿死了。哈哈。如果我们给一个约定，在拿筷子时，一下拿到一双，且吃完就交换给对方。则两个人都高高兴兴吃上饭了。筷子就是临界资源。当然，在两个人僵持的时候，可以进行外部干预，使得两个人都有饭吃。比如：强制一方将筷子空闲出来，则另一方饭就吃了。吃完了筷子空闲出来，则另一个人也有饭吃了。

     只要我们处理好临界资源问题，也就解决了线程安全问题。

     使用多线程，如果有临界资源，则必须进行线程同步处理。

**1.5.2 委托**

问题：线程间操作无效：从不是创建控件的线程访问它。

在多线程程序中，新创建的线程不能访问UI线程创建的窗口控件，如果需要访问窗口中的控件，可以在窗口构造函数中将CheckForIllegalCrossThreadCalls设置为 false。

.NET Framework 有助于在以非线程安全方式访问控件时检测到这一问题。在调试器中运行应用程序时，如果创建某控件的线程之外的其他线程试图调用该控件，则调试器会引发InvalidOperationException异常，并提示消息：“从不是创建控件 control name的线程访问它。”

从程序设计上来说,只有创建界面的主线程才能访问界面上的控件,所以会出错.

当然,设置CheckForIllegalCrossThreadCalls =false 是能去掉这个检查的,但是这不是标准的作法.

标准的作法是在访问界面控件时,访问下窗体的 InvokeRequired 属性,如果为false就可以直接访问,否则就是跨线程访问;此时,创建一个delegate,并通过Invoke() 来调用它.

delegate是C#中的一种类型，它实际上是一个能够持有对某个方法的引用的类。与其它的类不同，delegate类能够拥有一个签名（signature），并且它"只能持有与它的签名相匹配的方法的引用"。它所实现的功能与C/C++中的函数指针十分相似。它允许你传递一个类A的方法m给另一个类B的对象，使得类B的对象能够调用这个方法m。但与函数指针相比，delegate有许多函数委托和事件在 .Net Framework中的应用非常广泛指针不具备的优点。首先，函数指针只能指向静态函数，而delegate既可以引用静态函数，又可以引用非静态成员函数。在引用非静态成员函数时，delegate不但保存了对此函数入口指针的引用，而且还保存了调用此函数的类实例的引用。其次，与函数指针相比，delegate是面向对象、类型安全、可靠的受控（managed）对象。也就是说，runtime能够保证delegate指向一个有效的方法，你无须担心delegate会指向无效地址或者越界地址。

实现一个delegate是很简单的，通过以下3个步骤即可实现一个delegate：

（1） 声明一个delegate对象，它应当与你想要传递的方法具有相同的参数和返回值类型。

（2） 创建delegate对象，并"将你想要传递的函数作为参数传入"。

（3） 在要实现异步调用的地方，通过上一步创建的对象来调用方法。









 

