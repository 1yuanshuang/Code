# 1 大数的乘法和除法

## 1.1 问题描述

这几天的主要任务就是实现大数的乘法和除法，一开始问题想得有些简单，没有理解问题的本质，利用常规的乘除运算直接算出结果，导致算出的结果出现问题。例如无限制位数的除法后面的结果是错的。大数计算的因数和结果精度一般是少则数十位，多则几万位。在C语言中定义的类型中精度最多有20多位。因此当数的位数非常大时，常规的数据类型根本不足以存储。导致结果不正确。

## 1.2 思路

两个10位的小数相乘思路：转化成两个整数相乘，先把两个小数转换成整数（首先计算每个小数小数点后面有多少位，然后用这个小数乘以10的n（n就是这个小数小数点后面的位数）次方），转化好后就变为两个整数相乘，这两个整数是以字符串的形式传参的，相乘的结果也用字符串保存起来，最后再把结果转化为整数，再用这个整数除以10的m次方（m为两个小数小数点后面的位数之和）。

## 1.3 改进的算法

把这两个数以字符串的形式存储起来，去掉这两个小数中的小数点并获取小数点的位置，这样就把小数转化为整数了，然后模拟我们笔算乘法的过程实现代码按照“竖式计算”的思想，用乘数的每一位乘以被乘数，然后将每一次的计算结果相加。在每次相乘的过程中存在进位现象，而且此时进位不只是1，还存在更大的数。去掉开头是零的部分并给最终的结果设置小数点。去掉小数点并获取小数点的位置代码如下:

bool  BNStringPointPos(string& value,int& pos)

{

​	string tmp="";

​	int index=0;

​	for(;index<value.length();index++)

​	{

​		if(value[index]=='.')

​		{

​				pos=index;

​				tmp=value.substr(0,index);

​				break;

​		}

​	}

​	if(index!=value.size())

​	{

​		tmp+=value.substr(pos+1);

​		pos=value.size()-pos-1;

​		value=tmp;

​	}

return true;

}

## 1.4 遇到的问题

（1）上面的思路对一些位数比较小的小数相乘可以得到结果，但是输入的小数过长时就会出现死循环，在调试代码时，发现求小数小数点后面的位数出现死循环问题，这个函数的实现如下：

int bitNum(double number)

{

​	int count=0;

​	while(number!=(int)number)

​	{

​		number*=10;

​		count++;

​	}

​	return count;

}

产生问题的原因是给这个函数传入了一个double类型的参数，这本来就是错的，在C语言中定义的类型中精度最多有20多位。while(number!=(int)number)这里出现了死循环，这两个值永远不相等。因此这种方法不可取。

（2）在模拟笔算乘法的过程中出现问题，自己手算乘法很简单，列竖式一步一步乘，但是再把它转化成程序的过程中遇到些问题。包括存储每一位相乘的结果，以及进位问题。每一位相乘之后再加上进位才是最终的结果。还有一个问题就是把相乘的结果变量表示成Char* 类型的，这样数据的范围是-128~127，当你输入的两个数据很长时，错位相加的结果就会超出这个范围，因此将Char*改成 int *。

